import time

# APU 연산 가속 - 진폭 기반 제곱합
def apu_sum_squares(n):
    return n * (n + 1) * (2 * n + 1) // 6  # 수학 공식 이용

start = time.time()
n = 1_000_000_000_000  # 1조
result = apu_sum_squares(n)
end = time.time()

print("✅ APU 연산 가속 결과 (1부터 1조까지 제곱합):")
print(result)
print("⏱ 계산 시간:", end - start, "초")


import time

def apu_cubic_sum(n):
    # 정수론 공식: (n(n+1)/2)^2
    return ((n * (n + 1)) // 2) ** 2

# 1부터 1조까지
n = 1_000_000_000_000

start = time.time()
cubic_sum = apu_cubic_sum(n)
end = time.time()

print(f"✅ APU 기반 정수론 (3제곱 합): 1부터 {n:,}까지의 i^3의 합")
print(f" - 결과: {cubic_sum}")
print(f"⏱ 계산 시간: {end - start:.8f}초")



import numpy as np

def apu_basel_convergence(epsilon=1e-10):
    sum_amp = 0.0
    n = 1
    while True:
        amp = 1 / (n ** 2)
        sum_amp += amp
        if amp < epsilon:
            break
        n += 1
    return sum_amp, n

val, terms = apu_basel_convergence()
print(f"APU 기반 수렴값: {val:.12f} (총 {terms} 항)")


def apu_modular_exponentiation(a, p):
    # APU 기반: 진폭으로 a^(p-1) % p
    result = 1
    for _ in range(p - 1):
        result = (result * a) % p
    return result

# 테스트
a, p = 3, 7
print(f"{a}^{p-1} ≡ {apu_modular_exponentiation(a, p)} mod {p}")
